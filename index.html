<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>자격루 원리 시뮬레이션</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; font-family: 'Pretendard', sans-serif; }
        #ui-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 80%; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 40px; display: flex; align-items: center; gap: 20px;
            border: 1px solid #444; z-index: 100;
        }
        #time-slider { flex-grow: 1; accent-color: #ff4757; }
        .label { color: #fff; font-weight: bold; min-width: 60px; }
        #info { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; }
        #log { position: absolute; top: 20px; right: 20px; color: #00ffcc; font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>

<div id="info">
    <h1 style="margin:0; color:#fee140;">자격루(自擊漏) 원리 가동</h1>
    <p>슬라이더를 밀어 물을 채우세요. 수위가 차오르면 쇠구슬이 발사됩니다.</p>
</div>
<div id="log">상태: 대기 중</div>

<div id="ui-panel">
    <span class="label">수위 조절</span>
    <input type="range" id="time-slider" min="0" max="100" value="0">
    <span class="label">자동 보정</span>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // 1. 기초 세팅
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#1e272e');
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 10, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    
    // 조명
    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(5, 15, 10);
    light.castShadow = true;
    scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

    // 2. 자격루 구조물 (받침대 및 항아리)
    const woodMat = new THREE.MeshStandardMaterial({ color: '#5d4037' });
    const bronzeMat = new THREE.MeshStandardMaterial({ color: '#cd7f32', metalness: 0.7, roughness: 0.3 });
    const waterMat = new THREE.MeshStandardMaterial({ color: '#00d2ff', transparent: true, opacity: 0.7 });
    const goldMat = new THREE.MeshStandardMaterial({ color: '#ffd700', metalness: 0.9 });

    // 받침대 (가구)
    const base = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 6), woodMat);
    base.position.y = -0.5;
    scene.add(base);

    // 수수호 (물을 받는 통)
    const susuho = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 6, 32), bronzeMat);
    susuho.position.set(0, 3, 0);
    scene.add(susuho);

    // [물 객체] - 실제 수위가 변하는 메쉬
    const waterLevelMesh = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 1, 32), waterMat);
    waterLevelMesh.position.set(0, 0.5, 0);
    scene.add(waterLevelMesh);

    // [부표 및 잣대] - 물 위에 뜨는 장치
    const buoyGroup = new THREE.Group();
    const buoy = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.2, 32), woodMat);
    const rod = new THREE.Mesh(new THREE.BoxGeometry(0.2, 8, 0.2), goldMat); // 잣대
    rod.position.y = 4;
    buoyGroup.add(buoy, rod);
    buoyGroup.position.y = 0.5;
    scene.add(buoyGroup);

    // [방목] - 구슬이 굴러갈 통로
    const track = new THREE.Mesh(new THREE.BoxGeometry(8, 0.4, 0.6), woodMat);
    track.position.set(4, 5.5, 0);
    scene.add(track);

    // [쇠구슬]
    const ball = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), goldMat);
    ball.position.set(1, 5.8, 0); // 잣대 끝에 걸려있는 상태
    scene.add(ball);

    // 3. 시뮬레이션 로직
    const slider = document.getElementById('time-slider');
    const log = document.getElementById('log');
    
    let isRolling = false;

    slider.addEventListener('input', (e) => {
        if (isRolling) return; // 공이 구르는 중에는 입력 차단

        const level = e.target.value / 10; // 0 ~ 10 단위
        
        // 1. 물이 차오름
        waterLevelMesh.scale.y = level;
        waterLevelMesh.position.y = (level / 2);

        // 2. 부표가 물을 따라 올라감
        buoyGroup.position.y = level;

        // 3. 잣대가 공을 건드리는 시점 확인 (수위가 80% 이상일 때)
        if (level >= 5.5) {
            triggerBall();
        } else {
            ball.position.set(1, 5.8, 0); // 복귀
            log.innerText = "상태: 물이 차오르는 중...";
            log.style.color = "#00ffcc";
        }
    });

    function triggerBall() {
        if (isRolling) return;
        isRolling = true;
        log.innerText = "상태: 임계점 도달! 구슬 방출!";
        log.style.color = "#ff4757";

        // 구슬 굴러가기 애니메이션 (단순화)
        let speed = 0;
        const rollInterval = setInterval(() => {
            speed += 0.05;
            ball.position.x += speed;
            
            // 카메라가 구슬을 따라가도록 설정 (사용자 요청 반영)
            camera.lookAt(ball.position);

            if (ball.position.x > 8) {
                clearInterval(rollInterval);
                log.innerText = "상태: 징~ 시보 완료!";
                setTimeout(() => {
                    isRolling = false;
                    resetSystem();
                }, 2000);
            }
        }, 30);
    }

    function resetSystem() {
        slider.value = 0;
        waterLevelMesh.scale.y = 0.1;
        waterLevelMesh.position.y = 0.05;
        buoyGroup.position.y = 0;
        ball.position.set(1, 5.8, 0);
        camera.position.set(12, 10, 15);
        camera.lookAt(0, 3, 0);
        log.innerText = "상태: 대기 중";
    }

    // 4. 루프
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
